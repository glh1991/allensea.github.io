# 消息队列的使用场景

当时用消息队列的时候首先要考虑必要性, 不要盲目的选择消息队列来解决问题,一方面会带来开发维护的成本,而且很多场景是不合适的. 消息队列的使用场景常见的如下: 业务解耦/最终一致性/广播/错峰控流. 如果需要强一致性,关注业务的同步处理结果,最好采用RPC.

* **业务解耦**

    解耦是消息队列要解决的最本质问题。所谓解耦，简单点讲就是一个事务，只关心核心的流程。而需要依赖其他系统但不那么重要的事情，有通知即可，无需等待结果。换句话说，基于消息的模型，关心的是“通知”，而非“处理”。

    比如在脸脸的用户手机验证码登录注册的流程中, 客户端上传手机号点击获取验证码按钮, 这个时候服务端需要向一个第三方发送验证码的服务发出请求, 如果这个时候选择同步处理,那么对于客户端的响应速度就依赖于第三方发送验证码的响应速度. 这样就出现了业务上的耦合.完全可以向消息队列发送一条消息然后完成本次的HTTP请求响应过程,让后续的订阅者完成发送短信的任务,这样客户端的响应就会相对加快.

    再比如,解决跨语言跨系统的耦合也是一个适用场景. 由于历史原因,脸脸的技术栈比较多,老的系统使用Ruby on Rails开发,新的系统采用JAVA开发,同时脸脸的地理位置定位后端服务采用的是ElasticSearch+Scala.如何做到跨语言系统之间的服务调用变成了需要考虑的问题.最初的考虑是系统之间通过HTTP接口进行调用,这样简单一些. 其实不然,使用Rails(Mongo)开发的地点管理后台在运营人员进行地点数据的相关编辑以后需要将数据同步到Mysql(Java Server)和ElasticSearch(Scala server), 那么对于上层的地点管理系统就要知道自己的地点数据变更会对哪些下层系统会造成影响,且通过HTTP接口调用的方式导致的结果就是地点数据的变更接口的响应性能依赖了Java server和Scala Server的响应速度,如果不同系统之间的服务处理能力有差距,那么就会出现拥塞的情况.这种情况就适合使用消息队列, 当地点管理系统的数据发生变更,只需要向消息队列发布一条消息,完全不用关注其他业务系统,相关的业务系统自行订阅消费消息即可,这样就做到了解耦.

* **最终一致性**

    什么叫最终一致性,最终一致性指的是两个系统的状态保持一致，要么都成功，要么都失败。当然有个时间限制，理论上越快越好，但实际上在各种异常的情况下，可能会有一定延迟达到最终一致状态，但最后两个系统的状态是一样的。

    在脸脸的系统设计中也设计到最终一致性,由于场景比较新颖还是选择采用比较常见的场景事例来说明. 如比支付宝的转账流程.从支付宝的余额里转100块钱到银行卡上,这里就涉及到最终一致性.支付宝的余额-100且银行卡余额+100. 在以往的系统设计中事务充当了处理这类问题的角色, 数据库事务ACID原则: 原子性,一致性,隔离型,持久性.但是在分布式系统中,这些规则就已经不适用了. 这里有两个系统,一个是支付宝系统,一个是银行系统.让我们来看看这里可能会出现的意外情况:
    * 支付宝扣钱成功, 但是调用银行卡系统失败
    * 支付宝扣钱成功, 调用银行卡系统扣钱成功, 但是在获取最终结果时出现网络异常引起超时
    * 支付宝扣钱成功, 调用银行卡系统扣钱失败, 这个时候支付宝想要回滚扣钱操作,但是支付宝挂了

    看完以后是不是觉得很悲剧,就不能好好按照正常的流程给老子跑完吗? 程序的世界就是这样,一切皆可能. 我们要为这些随时可能出现的异常情况提供足够好的解决方案.

    最终一致性采用的是记录-补偿机制.在做所有不确定的事情之前把执行的操作记录下来,然后在去做.结果可能是: 成功, 失败, 超时(等同失败)等其他异常情况. 如果结果是成功的那么就把记录清理调.对于失败和不确定, 可以依靠定时任务把所有失败的事情重新处理一遍,直到成功为止.

    具体怎么做呢? 
    1. 利用Java Spring提供的@Transactional事务注解, 写一个本地方法,这个方法包括从支付宝余额中-100,并且添加一条-100的操作记录,再往消息队列发布一条消息. 可能你会担心如果发消息出现异常了怎么办? 没关系,@Transactional已经帮我们很好的处理这块异常, 如果发消息失败同样会回滚-100的操作记录.
    2. 消息队列的Consumer订阅消息,先判定这个消息是否被正确的消费了,如果被消费了则返回成功的状态,以避免消息重复消费,实现服务的幂等,然后处理银行卡的+100的操作.如果失败和其他异常情况都返回给消息队列重试的状态.消息队列收到消费结果是失败,则会反复重试直到成功(不同的消息队列的重试机制不一样). 如果消费成功,则需要记录订阅端已经成功消费了这条消息,以此避免重复消费消息.
    但是消息队列不是100%可靠,也是存在丢消息的情况,所以业务系统也要做一些措施来保证结果正确才能达到最终一致性.



    




