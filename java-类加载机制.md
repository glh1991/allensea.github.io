# 类加载机制

### 类加载机制
类加载机制分为几个步骤:

* 加载: 加载的过程是值, 将字节码转成Class类对象的过程, 比如读取编译后的.class文件, 将其转成byte数组, 通过defineClass得到类对象, 加载到内存中.
* 链接: 验证, 准备, 解析
  * 验证: 验证是指验证是否符合JVM规范, 避免对JVM造成危害
  * 准备: 准备的过程是在方法区中分配内存空间, 将类运行时的数据结构加载到方法区中, 包括初始化类的静态变量, 常量等
  * 解析: 解析的过程是从直接引用转成间接引用的过程
* 初始化: 初始化的过程是调用类构造器的过程,将静态变量和静态代码块进行合并, 得到结果. 如果有父类, 那么先调用父类的类构造器
* 使用
* 销毁

关于初始化的时机, 主动引用时会进行初始化:

* 通过new构造一个实例
* 通过反射构造类对象
* 使用类的静态变量或静态方法(final域除外, final域在编译时完成)

### 类加载器

#### 双亲委托类加载器

类加载器分为多种:

* bootstrap classloader: 底层c实现, 应用程序中不能修改, 用来加载JAVA_HOME/lib/rt.jar
* ext classloader: 扩展类加载器, 加载JAVA_HOME/ext/*.jar, 由jdk实现
* Application classloader: 应用加载器, 加载classpath下的类
* 自定义加载器

双亲委托加载机制按照上面的类加载器分类从上至下组成逻辑上的父子关系, 当加载一个类时, 先看这个类是否已经加载, 如果没有加载则委托到顶层的加载器加载, 一层层往下使用加载器加载, 直到加载成功为止, 如果加载失败, 则抛出异常.这样做的好处是为了安全, 比如说用户自定义了一个java.lang.Object类, 这个时候从bootstrap classloader开始加载, 那么就会使用库的类, 而不会使用用户自定义的类.

#### 自定义加载器

#### 线程上下文加载机制

比如jdbc的接口定义在扩展包里, 但是jdbc的实现由各个数据库厂商实现, 并不在扩展包里, 这个时候就采用线程上下文加载机制,来加载类.

#### web服务器的加载机制


